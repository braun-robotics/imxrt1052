#[doc = r" Value read from the register"]
pub struct R {
    bits: u32,
}
#[doc = r" Value to write to the register"]
pub struct W {
    bits: u32,
}
impl super::MCR0 {
    #[doc = r" Modifies the contents of the register"]
    #[inline]
    pub fn modify<F>(&self, f: F)
    where
        for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
    {
        let bits = self.register.get();
        let r = R { bits: bits };
        let mut w = W { bits: bits };
        f(&r, &mut w);
        self.register.set(w.bits);
    }
    #[doc = r" Reads the contents of the register"]
    #[inline]
    pub fn read(&self) -> R {
        R {
            bits: self.register.get(),
        }
    }
    #[doc = r" Writes to the register"]
    #[inline]
    pub fn write<F>(&self, f: F)
    where
        F: FnOnce(&mut W) -> &mut W,
    {
        let mut w = W::reset_value();
        f(&mut w);
        self.register.set(w.bits);
    }
    #[doc = r" Writes the reset value to the register"]
    #[inline]
    pub fn reset(&self) {
        self.write(|w| w)
    }
}
#[doc = r" Value of the field"]
pub struct SWRESETR {
    bits: bool,
}
impl SWRESETR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct MDISR {
    bits: bool,
}
impl MDISR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = "Possible values of the field `RXCLKSRC`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum RXCLKSRCR {
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    RXCLKSRC_0,
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    RXCLKSRC_1,
    #[doc = "Flash provided Read strobe and input from DQS pad"]
    RXCLKSRC_3,
    #[doc = r" Reserved"]
    _Reserved(u8),
}
impl RXCLKSRCR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        match *self {
            RXCLKSRCR::RXCLKSRC_0 => 0,
            RXCLKSRCR::RXCLKSRC_1 => 1,
            RXCLKSRCR::RXCLKSRC_3 => 3,
            RXCLKSRCR::_Reserved(bits) => bits,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: u8) -> RXCLKSRCR {
        match value {
            0 => RXCLKSRCR::RXCLKSRC_0,
            1 => RXCLKSRCR::RXCLKSRC_1,
            3 => RXCLKSRCR::RXCLKSRC_3,
            i => RXCLKSRCR::_Reserved(i),
        }
    }
    #[doc = "Checks if the value of the field is `RXCLKSRC_0`"]
    #[inline]
    pub fn is_rxclksrc_0(&self) -> bool {
        *self == RXCLKSRCR::RXCLKSRC_0
    }
    #[doc = "Checks if the value of the field is `RXCLKSRC_1`"]
    #[inline]
    pub fn is_rxclksrc_1(&self) -> bool {
        *self == RXCLKSRCR::RXCLKSRC_1
    }
    #[doc = "Checks if the value of the field is `RXCLKSRC_3`"]
    #[inline]
    pub fn is_rxclksrc_3(&self) -> bool {
        *self == RXCLKSRCR::RXCLKSRC_3
    }
}
#[doc = "Possible values of the field `ARDFEN`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum ARDFENR {
    #[doc = "IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response."]
    ARDFEN_0,
    #[doc = "IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response."]
    ARDFEN_1,
}
impl ARDFENR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            ARDFENR::ARDFEN_0 => false,
            ARDFENR::ARDFEN_1 => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> ARDFENR {
        match value {
            false => ARDFENR::ARDFEN_0,
            true => ARDFENR::ARDFEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `ARDFEN_0`"]
    #[inline]
    pub fn is_ardfen_0(&self) -> bool {
        *self == ARDFENR::ARDFEN_0
    }
    #[doc = "Checks if the value of the field is `ARDFEN_1`"]
    #[inline]
    pub fn is_ardfen_1(&self) -> bool {
        *self == ARDFENR::ARDFEN_1
    }
}
#[doc = "Possible values of the field `ATDFEN`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum ATDFENR {
    #[doc = "IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response."]
    ATDFEN_0,
    #[doc = "IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response."]
    ATDFEN_1,
}
impl ATDFENR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            ATDFENR::ATDFEN_0 => false,
            ATDFENR::ATDFEN_1 => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> ATDFENR {
        match value {
            false => ATDFENR::ATDFEN_0,
            true => ATDFENR::ATDFEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `ATDFEN_0`"]
    #[inline]
    pub fn is_atdfen_0(&self) -> bool {
        *self == ATDFENR::ATDFEN_0
    }
    #[doc = "Checks if the value of the field is `ATDFEN_1`"]
    #[inline]
    pub fn is_atdfen_1(&self) -> bool {
        *self == ATDFENR::ATDFEN_1
    }
}
#[doc = "Possible values of the field `HSEN`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum HSENR {
    #[doc = "Disable divide by 2 of serial flash clock for half speed commands."]
    HSEN_0,
    #[doc = "Enable divide by 2 of serial flash clock for half speed commands."]
    HSEN_1,
}
impl HSENR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            HSENR::HSEN_0 => false,
            HSENR::HSEN_1 => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> HSENR {
        match value {
            false => HSENR::HSEN_0,
            true => HSENR::HSEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `HSEN_0`"]
    #[inline]
    pub fn is_hsen_0(&self) -> bool {
        *self == HSENR::HSEN_0
    }
    #[doc = "Checks if the value of the field is `HSEN_1`"]
    #[inline]
    pub fn is_hsen_1(&self) -> bool {
        *self == HSENR::HSEN_1
    }
}
#[doc = "Possible values of the field `DOZEEN`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DOZEENR {
    #[doc = "Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    DOZEEN_0,
    #[doc = "Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    DOZEEN_1,
}
impl DOZEENR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            DOZEENR::DOZEEN_0 => false,
            DOZEENR::DOZEEN_1 => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> DOZEENR {
        match value {
            false => DOZEENR::DOZEEN_0,
            true => DOZEENR::DOZEEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `DOZEEN_0`"]
    #[inline]
    pub fn is_dozeen_0(&self) -> bool {
        *self == DOZEENR::DOZEEN_0
    }
    #[doc = "Checks if the value of the field is `DOZEEN_1`"]
    #[inline]
    pub fn is_dozeen_1(&self) -> bool {
        *self == DOZEENR::DOZEEN_1
    }
}
#[doc = "Possible values of the field `COMBINATIONEN`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum COMBINATIONENR {
    #[doc = "Disable."]
    COMBINATIONEN_0,
    #[doc = "Enable."]
    COMBINATIONEN_1,
}
impl COMBINATIONENR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            COMBINATIONENR::COMBINATIONEN_0 => false,
            COMBINATIONENR::COMBINATIONEN_1 => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> COMBINATIONENR {
        match value {
            false => COMBINATIONENR::COMBINATIONEN_0,
            true => COMBINATIONENR::COMBINATIONEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `COMBINATIONEN_0`"]
    #[inline]
    pub fn is_combinationen_0(&self) -> bool {
        *self == COMBINATIONENR::COMBINATIONEN_0
    }
    #[doc = "Checks if the value of the field is `COMBINATIONEN_1`"]
    #[inline]
    pub fn is_combinationen_1(&self) -> bool {
        *self == COMBINATIONENR::COMBINATIONEN_1
    }
}
#[doc = "Possible values of the field `SCKFREERUNEN`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum SCKFREERUNENR {
    #[doc = "Disable."]
    SCKFREERUNEN_0,
    #[doc = "Enable."]
    SCKFREERUNEN_1,
}
impl SCKFREERUNENR {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            SCKFREERUNENR::SCKFREERUNEN_0 => false,
            SCKFREERUNENR::SCKFREERUNEN_1 => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> SCKFREERUNENR {
        match value {
            false => SCKFREERUNENR::SCKFREERUNEN_0,
            true => SCKFREERUNENR::SCKFREERUNEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `SCKFREERUNEN_0`"]
    #[inline]
    pub fn is_sckfreerunen_0(&self) -> bool {
        *self == SCKFREERUNENR::SCKFREERUNEN_0
    }
    #[doc = "Checks if the value of the field is `SCKFREERUNEN_1`"]
    #[inline]
    pub fn is_sckfreerunen_1(&self) -> bool {
        *self == SCKFREERUNENR::SCKFREERUNEN_1
    }
}
#[doc = r" Value of the field"]
pub struct IPGRANTWAITR {
    bits: u8,
}
impl IPGRANTWAITR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        self.bits
    }
}
#[doc = r" Value of the field"]
pub struct AHBGRANTWAITR {
    bits: u8,
}
impl AHBGRANTWAITR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        self.bits
    }
}
#[doc = r" Proxy"]
pub struct _SWRESETW<'a> {
    w: &'a mut W,
}
impl<'a> _SWRESETW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 0;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _MDISW<'a> {
    w: &'a mut W,
}
impl<'a> _MDISW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 1;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `RXCLKSRC`"]
pub enum RXCLKSRCW {
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    RXCLKSRC_0,
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    RXCLKSRC_1,
    #[doc = "Flash provided Read strobe and input from DQS pad"]
    RXCLKSRC_3,
}
impl RXCLKSRCW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> u8 {
        match *self {
            RXCLKSRCW::RXCLKSRC_0 => 0,
            RXCLKSRCW::RXCLKSRC_1 => 1,
            RXCLKSRCW::RXCLKSRC_3 => 3,
        }
    }
}
#[doc = r" Proxy"]
pub struct _RXCLKSRCW<'a> {
    w: &'a mut W,
}
impl<'a> _RXCLKSRCW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: RXCLKSRCW) -> &'a mut W {
        unsafe { self.bits(variant._bits()) }
    }
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    #[inline]
    pub fn rxclksrc_0(self) -> &'a mut W {
        self.variant(RXCLKSRCW::RXCLKSRC_0)
    }
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    #[inline]
    pub fn rxclksrc_1(self) -> &'a mut W {
        self.variant(RXCLKSRCW::RXCLKSRC_1)
    }
    #[doc = "Flash provided Read strobe and input from DQS pad"]
    #[inline]
    pub fn rxclksrc_3(self) -> &'a mut W {
        self.variant(RXCLKSRCW::RXCLKSRC_3)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub unsafe fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 3;
        const OFFSET: u8 = 4;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `ARDFEN`"]
pub enum ARDFENW {
    #[doc = "IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response."]
    ARDFEN_0,
    #[doc = "IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response."]
    ARDFEN_1,
}
impl ARDFENW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            ARDFENW::ARDFEN_0 => false,
            ARDFENW::ARDFEN_1 => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _ARDFENW<'a> {
    w: &'a mut W,
}
impl<'a> _ARDFENW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: ARDFENW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response."]
    #[inline]
    pub fn ardfen_0(self) -> &'a mut W {
        self.variant(ARDFENW::ARDFEN_0)
    }
    #[doc = "IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response."]
    #[inline]
    pub fn ardfen_1(self) -> &'a mut W {
        self.variant(ARDFENW::ARDFEN_1)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 6;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `ATDFEN`"]
pub enum ATDFENW {
    #[doc = "IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response."]
    ATDFEN_0,
    #[doc = "IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response."]
    ATDFEN_1,
}
impl ATDFENW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            ATDFENW::ATDFEN_0 => false,
            ATDFENW::ATDFEN_1 => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _ATDFENW<'a> {
    w: &'a mut W,
}
impl<'a> _ATDFENW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: ATDFENW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response."]
    #[inline]
    pub fn atdfen_0(self) -> &'a mut W {
        self.variant(ATDFENW::ATDFEN_0)
    }
    #[doc = "IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response."]
    #[inline]
    pub fn atdfen_1(self) -> &'a mut W {
        self.variant(ATDFENW::ATDFEN_1)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 7;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `HSEN`"]
pub enum HSENW {
    #[doc = "Disable divide by 2 of serial flash clock for half speed commands."]
    HSEN_0,
    #[doc = "Enable divide by 2 of serial flash clock for half speed commands."]
    HSEN_1,
}
impl HSENW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            HSENW::HSEN_0 => false,
            HSENW::HSEN_1 => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _HSENW<'a> {
    w: &'a mut W,
}
impl<'a> _HSENW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: HSENW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Disable divide by 2 of serial flash clock for half speed commands."]
    #[inline]
    pub fn hsen_0(self) -> &'a mut W {
        self.variant(HSENW::HSEN_0)
    }
    #[doc = "Enable divide by 2 of serial flash clock for half speed commands."]
    #[inline]
    pub fn hsen_1(self) -> &'a mut W {
        self.variant(HSENW::HSEN_1)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 11;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `DOZEEN`"]
pub enum DOZEENW {
    #[doc = "Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    DOZEEN_0,
    #[doc = "Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    DOZEEN_1,
}
impl DOZEENW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            DOZEENW::DOZEEN_0 => false,
            DOZEENW::DOZEEN_1 => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _DOZEENW<'a> {
    w: &'a mut W,
}
impl<'a> _DOZEENW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: DOZEENW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    #[inline]
    pub fn dozeen_0(self) -> &'a mut W {
        self.variant(DOZEENW::DOZEEN_0)
    }
    #[doc = "Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    #[inline]
    pub fn dozeen_1(self) -> &'a mut W {
        self.variant(DOZEENW::DOZEEN_1)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 12;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `COMBINATIONEN`"]
pub enum COMBINATIONENW {
    #[doc = "Disable."]
    COMBINATIONEN_0,
    #[doc = "Enable."]
    COMBINATIONEN_1,
}
impl COMBINATIONENW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            COMBINATIONENW::COMBINATIONEN_0 => false,
            COMBINATIONENW::COMBINATIONEN_1 => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _COMBINATIONENW<'a> {
    w: &'a mut W,
}
impl<'a> _COMBINATIONENW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: COMBINATIONENW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Disable."]
    #[inline]
    pub fn combinationen_0(self) -> &'a mut W {
        self.variant(COMBINATIONENW::COMBINATIONEN_0)
    }
    #[doc = "Enable."]
    #[inline]
    pub fn combinationen_1(self) -> &'a mut W {
        self.variant(COMBINATIONENW::COMBINATIONEN_1)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 13;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `SCKFREERUNEN`"]
pub enum SCKFREERUNENW {
    #[doc = "Disable."]
    SCKFREERUNEN_0,
    #[doc = "Enable."]
    SCKFREERUNEN_1,
}
impl SCKFREERUNENW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            SCKFREERUNENW::SCKFREERUNEN_0 => false,
            SCKFREERUNENW::SCKFREERUNEN_1 => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _SCKFREERUNENW<'a> {
    w: &'a mut W,
}
impl<'a> _SCKFREERUNENW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: SCKFREERUNENW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "Disable."]
    #[inline]
    pub fn sckfreerunen_0(self) -> &'a mut W {
        self.variant(SCKFREERUNENW::SCKFREERUNEN_0)
    }
    #[doc = "Enable."]
    #[inline]
    pub fn sckfreerunen_1(self) -> &'a mut W {
        self.variant(SCKFREERUNENW::SCKFREERUNEN_1)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 14;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _IPGRANTWAITW<'a> {
    w: &'a mut W,
}
impl<'a> _IPGRANTWAITW<'a> {
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub unsafe fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 255;
        const OFFSET: u8 = 16;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _AHBGRANTWAITW<'a> {
    w: &'a mut W,
}
impl<'a> _AHBGRANTWAITW<'a> {
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub unsafe fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 255;
        const OFFSET: u8 = 24;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
impl R {
    #[doc = r" Value of the register as raw bits"]
    #[inline]
    pub fn bits(&self) -> u32 {
        self.bits
    }
    #[doc = "Bit 0 - Software Reset"]
    #[inline]
    pub fn swreset(&self) -> SWRESETR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 0;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        SWRESETR { bits }
    }
    #[doc = "Bit 1 - Module Disable"]
    #[inline]
    pub fn mdis(&self) -> MDISR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 1;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        MDISR { bits }
    }
    #[doc = "Bits 4:5 - Sample Clock source selection for Flash Reading"]
    #[inline]
    pub fn rxclksrc(&self) -> RXCLKSRCR {
        RXCLKSRCR::_from({
            const MASK: u8 = 3;
            const OFFSET: u8 = 4;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        })
    }
    #[doc = "Bit 6 - Enable AHB bus Read Access to IP RX FIFO."]
    #[inline]
    pub fn ardfen(&self) -> ARDFENR {
        ARDFENR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 6;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 7 - Enable AHB bus Write Access to IP TX FIFO."]
    #[inline]
    pub fn atdfen(&self) -> ATDFENR {
        ATDFENR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 7;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 11 - Half Speed Serial Flash access Enable."]
    #[inline]
    pub fn hsen(&self) -> HSENR {
        HSENR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 11;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 12 - Doze mode enable bit"]
    #[inline]
    pub fn dozeen(&self) -> DOZEENR {
        DOZEENR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 12;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 13 - This bit is to support Flash Octal mode access by combining Port A and B Data pins (SIOA[3:0] and SIOB[3:0])."]
    #[inline]
    pub fn combinationen(&self) -> COMBINATIONENR {
        COMBINATIONENR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 13;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bit 14 - This bit is used to force SCK output free-running. For FPGA applications, external device may use SCK clock as reference clock to its internal PLL. If SCK free-running is enabled, data sampling with loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2)."]
    #[inline]
    pub fn sckfreerunen(&self) -> SCKFREERUNENR {
        SCKFREERUNENR::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 14;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bits 16:23 - Time out wait cycle for IP command grant."]
    #[inline]
    pub fn ipgrantwait(&self) -> IPGRANTWAITR {
        let bits = {
            const MASK: u8 = 255;
            const OFFSET: u8 = 16;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        };
        IPGRANTWAITR { bits }
    }
    #[doc = "Bits 24:31 - Timeout wait cycle for AHB command grant."]
    #[inline]
    pub fn ahbgrantwait(&self) -> AHBGRANTWAITR {
        let bits = {
            const MASK: u8 = 255;
            const OFFSET: u8 = 24;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        };
        AHBGRANTWAITR { bits }
    }
}
impl W {
    #[doc = r" Reset value of the register"]
    #[inline]
    pub fn reset_value() -> W {
        W { bits: 4294934722 }
    }
    #[doc = r" Writes raw bits to the register"]
    #[inline]
    pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
        self.bits = bits;
        self
    }
    #[doc = "Bit 0 - Software Reset"]
    #[inline]
    pub fn swreset(&mut self) -> _SWRESETW {
        _SWRESETW { w: self }
    }
    #[doc = "Bit 1 - Module Disable"]
    #[inline]
    pub fn mdis(&mut self) -> _MDISW {
        _MDISW { w: self }
    }
    #[doc = "Bits 4:5 - Sample Clock source selection for Flash Reading"]
    #[inline]
    pub fn rxclksrc(&mut self) -> _RXCLKSRCW {
        _RXCLKSRCW { w: self }
    }
    #[doc = "Bit 6 - Enable AHB bus Read Access to IP RX FIFO."]
    #[inline]
    pub fn ardfen(&mut self) -> _ARDFENW {
        _ARDFENW { w: self }
    }
    #[doc = "Bit 7 - Enable AHB bus Write Access to IP TX FIFO."]
    #[inline]
    pub fn atdfen(&mut self) -> _ATDFENW {
        _ATDFENW { w: self }
    }
    #[doc = "Bit 11 - Half Speed Serial Flash access Enable."]
    #[inline]
    pub fn hsen(&mut self) -> _HSENW {
        _HSENW { w: self }
    }
    #[doc = "Bit 12 - Doze mode enable bit"]
    #[inline]
    pub fn dozeen(&mut self) -> _DOZEENW {
        _DOZEENW { w: self }
    }
    #[doc = "Bit 13 - This bit is to support Flash Octal mode access by combining Port A and B Data pins (SIOA[3:0] and SIOB[3:0])."]
    #[inline]
    pub fn combinationen(&mut self) -> _COMBINATIONENW {
        _COMBINATIONENW { w: self }
    }
    #[doc = "Bit 14 - This bit is used to force SCK output free-running. For FPGA applications, external device may use SCK clock as reference clock to its internal PLL. If SCK free-running is enabled, data sampling with loopback clock from SCK pad is not supported (MCR0[RXCLKSRC]=2)."]
    #[inline]
    pub fn sckfreerunen(&mut self) -> _SCKFREERUNENW {
        _SCKFREERUNENW { w: self }
    }
    #[doc = "Bits 16:23 - Time out wait cycle for IP command grant."]
    #[inline]
    pub fn ipgrantwait(&mut self) -> _IPGRANTWAITW {
        _IPGRANTWAITW { w: self }
    }
    #[doc = "Bits 24:31 - Timeout wait cycle for AHB command grant."]
    #[inline]
    pub fn ahbgrantwait(&mut self) -> _AHBGRANTWAITW {
        _AHBGRANTWAITW { w: self }
    }
}
